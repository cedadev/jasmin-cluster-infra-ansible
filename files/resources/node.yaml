---
heat_template_version: queens


description: >
  Resource for a cluster node.


parameters:
  cluster_name:
    type: string
    label: The name of the cluster

  cluster_image:
    type: string
    label: The image to use for cluster nodes (must be CentOS 7)
    constraints:
      - custom_constraint: glance.image

  cluster_user_keypair:
    type: string
    label: SSH key pair for user access to the cluster
    constraints:
      - custom_constraint: nova.keypair

  cluster_deploy_public_key:
    type: string
    label: SSH public key for deployments to the cluster

  cluster_group:
    type: json
    label: Dictionary of properties for the node group

  node_idx:
    type: number
    label: Node index within group

  node_ports:
    type: json
    label: List of primary port resources for all nodes in this group

  primary_ips:
    type: json
    label: List of primary IP addresses for all nodes in this group


conditions:
  root_volume:
    yaql:
      expression: $.data.containsKey('root_volume_size')
      data: { get_param: cluster_group }

  # It would be great to use a resource group to create an arbitrary number
  # of volumes, but it takes us past the default maximum nesting depth
  # So the hack is to allow the creation of up to a certain number of volumes
  # using static definitions
  volume_1:
    yaql:
      expression: $.data.get('additional_volumes', []).len() >= 1
      data: { get_param: cluster_group }

  volume_2:
    yaql:
      expression: $.data.get('additional_volumes', []).len() >= 2
      data: { get_param: cluster_group }

  volume_3:
    yaql:
      expression: $.data.get('additional_volumes', []).len() >= 3
      data: { get_param: cluster_group }


resources:
  server_name:
    type: OS::Heat::Value
    properties:
      value:
        list_join:
          - '-'
          - - { get_param: cluster_name }
            - { get_param: [cluster_group, name] }
            # list_join requires that we convert the int to a string
            - str_replace:
                template: "%node_idx%"
                params:
                  "%node_idx%": { get_param: node_idx }

  server_config:
    type: OS::Heat::CloudConfig
    properties:
      cloud_config:
        ssh_authorized_keys:
          - { get_param: cluster_deploy_public_key }

  # Unfortunately we can't have a single server definition for both image and
  # root volume (I tried every possible combination of things!!!)
  # We can't even share the properties because the "properties" section cannot
  # be an intrinsic, e.g. merge_map
  server_with_volume:
    condition: root_volume
    type: OS::Nova::Server
    properties:
      name: { get_attr: [server_name, value] }
      flavor: { get_param: [cluster_group, flavor] }
      key_name: { get_param: cluster_user_keypair }
      networks:
        - port: { get_param: [node_ports, { get_param: node_idx }] }
      block_device_mapping_v2:
        - boot_index: 0
          image: { get_param: cluster_image }
          volume_size: { get_param: [cluster_group, root_volume_size] }
          delete_on_termination: true
      user_data_format: SOFTWARE_CONFIG
      user_data: { get_resource: server_config }

  server_with_image:
    condition: { not: root_volume }
    type: OS::Nova::Server
    properties:
      name: { get_attr: [server_name, value] }
      flavor: { get_param: [cluster_group, flavor] }
      key_name: { get_param: cluster_user_keypair }
      networks:
        - port: { get_param: [node_ports, { get_param: node_idx }] }
      image: { get_param: cluster_image }
      user_data_format: SOFTWARE_CONFIG
      user_data: { get_resource: server_config }

  # It would be great to use a resource group to create an arbitrary number
  # of volumes, but it takes us past the default maximum nesting depth
  # So the hack is to allow the creation of up to a certain number of volumes
  # using static definitions
  volume_1:
    condition: volume_1
    type: OS::Cinder::Volume
    properties:
      name:
        list_join:
          - '-'
          - [ { get_attr: [server_name, value] },
              { get_param: [cluster_group, additional_volumes, 0, name] } ]
      size: { get_param: [cluster_group, additional_volumes, 0, size] }

  volume_1_attach:
    condition: volume_1
    type: OS::Cinder::VolumeAttachment
    properties:
      instance_uuid:
        if:
          - root_volume
          - { get_resource: server_with_volume }
          - { get_resource: server_with_image }
      volume_id: { get_resource: volume_1 }
      mountpoint: { get_param: [cluster_group, additional_volumes, 0, device] }

  volume_2:
    condition: volume_2
    type: OS::Cinder::Volume
    properties:
      name:
        list_join:
          - '-'
          - [ { get_attr: [server_name, value] },
              { get_param: [cluster_group, additional_volumes, 1, name] } ]
      size: { get_param: [cluster_group, additional_volumes, 1, size] }

  volume_2_attach:
    condition: volume_2
    type: OS::Cinder::VolumeAttachment
    properties:
      instance_uuid:
        if:
          - root_volume
          - { get_resource: server_with_volume }
          - { get_resource: server_with_image }
      volume_id: { get_resource: volume_2 }
      mountpoint: { get_param: [cluster_group, additional_volumes, 1, device] }

  volume_3:
    condition: volume_3
    type: OS::Cinder::Volume
    properties:
      name:
        list_join:
          - '-'
          - [ { get_attr: [server_name, value] },
              { get_param: [cluster_group, additional_volumes, 2, name] } ]
      size: { get_param: [cluster_group, additional_volumes, 2, size] }

  volume_3_attach:
    condition: volume_3
    type: OS::Cinder::VolumeAttachment
    properties:
      instance_uuid:
        if:
          - root_volume
          - { get_resource: server_with_volume }
          - { get_resource: server_with_image }
      volume_id: { get_resource: volume_3 }
      mountpoint: { get_param: [cluster_group, additional_volumes, 2, device] }


outputs:
  OS::stack_id:
    value:
      if:
        - root_volume
        - { get_resource: server_with_volume }
        - { get_resource: server_with_image }

  instance_data:
    value:
      id:
        if:
          - root_volume
          - { get_resource: server_with_volume }
          - { get_resource: server_with_image }
      name: { get_attr: [server_name, value] }
      ip: { get_param: [primary_ips, { get_param: node_idx }] }
      inventory_groups: { get_param: [cluster_group, inventory_groups] }
      # Include information about the volumes in the node facts
      facts:
        map_merge:
          - yaql:
              expression: $.data.get('facts', {})
              data: { get_param: cluster_group }
          - cluster_attached_volumes:
              yaql:
                expression: $.data.get('additional_volumes', [])
                data: { get_param: cluster_group }
